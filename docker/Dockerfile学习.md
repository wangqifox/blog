---
title: Dockerfile学习
date: 2019/06/10 22:16:00
---

本文是对Dockerfile学习的整理

<!-- more -->

## Docker build命令

docker build命令用于使用Dockerfile创建镜像。

语法：`docker build [OPTIONS] PATH | URL | -`

OPTIONS说明：

- `--build-arg=[]`：设置镜像创建时的变量
- `--cpu-shares`：设置CPU使用权重
- `--cpu-period`：限制CPU CFS周期
- `--cpu-quota`：限制CPU CFS配额
- `--cpuset-cpus`：指定使用的CPU id
- `--cpuset-mems`：指定使用的内存id
- `--disable-content-trust`：忽略校验，默认开启
- `-f`：指定要使用的Dockerfile路径
- `--force-rm`：设置镜像过程中删除中间容器
- `--isolation`：使用容器隔离技术
- `--label=[]`：设置镜像使用的元数据
- `-m`：设置内存最大值
- `--memory-swap`：设置swap的最大值为内存+swap，`-1`表示不限swap
- `--no-cache`：创建镜像的过程不使用缓存
- `--pull`：尝试去更新镜像的新版本
- `--quiet,-q`：安静模式，成功后只输出镜像ID
- `--rm`：设置镜像成功后删除中间容器
- `--shm-size`：设置`/dev/shm`的大小，默认值是64M
- `--ulimit`：ulimit的配置
- `--tag,t`：镜像的名字及标签，通常`name:tag`或者`name`格式；可以在一次构建中为一个镜像设置多个标签
- `--network`：默认`default`。在构建期间设置`RUN`指令的网络模式

## 指令说明

### FROM

指定基础镜像。FROM是必备指令，并且必须是第一条指令。

### RUN执行命令

`RUN`指令用于执行命令行命令。

格式：

- `RUN <命令>`
- `RUN ["可执行文件", "参数1", "参数2"]`

### COPY复制文件

格式：

- `COPY [--chown=<user>:<group>] <源路径>... <目标路径>`
- `COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]`

`COPY`指令将从构建上下文目录中`<源路径>`的文件/目录复制到新的一层的镜像内的`<目标路径>`位置。

`<源路径>`可以是多个，甚至可以是通配符。

`<目标路径>`可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用`WORKDIR`指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

使用`COPY`指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用git进行管理的时候。

### ADD 更高级的复制文件

`ADD`指令和`COPY`的格式和性质基本一致。但是在`COPY`基础上增加了一些功能。

比如`<源路径>`可以是一个`URL`，这种情况下，Docker引擎会试图去下载这个链接的文件放到`<目标路径>`去。下载后的文件权限自动设置为`600`，如果这并不是想要的权限，那么还需要增加额外的一层`RUN`指令进行解压缩。所以不如直接使用`RUN`指令，然后使用`wget`或者`curl`工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实不实用，而且不推荐使用。

如果`<源路径>`为一个`tar`压缩文件的话，压缩格式为`gzip`,`bzip2`以及`xz`的情况下，`ADD`指令将自动解压缩这个压缩文件到`<目标路径>`去。

### CMD 容器启动命令

格式：

- `shell`格式：`CMD <命令>`
- `exec`格式：`CMD ["可执行文件", "参数1", "参数2"...]`
- 参数列表格式：`CMD ["参数1", "参数2"...]`。在指定了`ENTRYPOINT`指令后，用`CMD`指定具体的参数。

Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD`指令就是用于指定默认的容器主进程的启动命令的。

Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用`systemd`去启动后台服务，容器内没有后台服务的概念。

对于容易而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其他辅助进行不是它需要关心的东西。

### ENTRYPOINT入口点

`ENTRYPOINT`的格式和`RUN`指令格式一样，分为`exec`格式和`shell`格式。

`ENTRYPOINT`的目的和`CMD`一样，都是在指定容器启动程序及参数。`ENTRYPOINT`在运行时也可以替代，不过比`CMD`要略显繁琐，需要通过`docker run`的参数`--entrypoint`来指定。

当指定了`ENTRYPOINT`后，`CMD`的含义就发生了改变，不再是直接的运行其命令，而是将`CMD`的内容作为参数传给`ENTRYPOINT`指令，换句话说实际执行时，将变为：

`<ENTRYPOINT> "<CMD>"`

### ENV设置环境变量

格式有两种：

- `ENV <key> <value>`
- `ENV <key1>=<value1> <key2>=<value2>...`

这个指令很简单，就是设置环境变量而已，无论是后面的其他指令，如`RUN`，还是运行时的应用，都可以直接使用这里定义的环境变量。

下列指令可以支持环境变量展开：

`ADD`、`COPY`、`ENV`、`EXPOSE`、`LABEL`、`USER`、`WORKDIR`、`VOLUME`、`STOPSIGNAL`、`ONBUILD`。

### ARG构建参数

格式：`ARG <参数名>[=<默认值>]`

构建参数和`ENV`的效果一样，都是设置环境变量。所不同的是，`ARG`所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用`ARG`保存密码之类的信息，因为`docker history`还是可以看到所有值的。

`Dockerfile`中的`ARG`指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令`docker build`中用`--build-arg <参数名>=<值>`来覆盖。

### VOLUME定义匿名卷

格式：

- `VOLUME ["<路径1>", "<路径2>"...]`
- `VOLUME <路径>`

容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在`Dockerfile`中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。

`VOLUME /data`

这里的`/data`目录就会在运行时自动挂载为匿名卷，任何向`/data`中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：

`docker run -d -v mydata:/data xxxx`

在这个命令中，就使用了`mydata`这个命名卷挂载到了`/data`这个位置，替代了`Dockerfile`中定义的匿名卷的挂载配置。

### EXPOSE声明端口

格式为：`EXPOSE <端口1> [<端口2>...]`

`EXPOSE`指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在`Dockerfile`中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是`docker run -P`时，会自动随机映射`EXPOSE`的端口。

要将`EXPOSE`和在运行时使用`-p <宿主端口>:<容器端口>`区分开来。`-p`是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而`EXPOSE`仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。

### WORKDIR指定工作目录

格式为`WORKDIR <工作目录路径>`

使用`WORKDIR`指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR`会帮你建立目录。

### USER指定当前用户

格式：`USER <用户名>[:<用户组>]`

`USER`指令和`WORKDIR`相似，都是改变环境状态并影响以后的层。`WORKDIR`是改变工作目录，`USER`则是改变之后层的执行`RUN`、`CMD`以及`ENTRYPOINT`这类命令的身份。

当然，和`WORKDIR`一样，`USER`只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。

### HEALTHCHECK健康检查

格式：

- `HEALTHCHECK [选项] CMD <命令>`：设置检查容器健康状况的命令
- `HEALTHCHECK NONE`：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令。

`HEALTHCHECK`指令是告诉Docker应该如何进行判断容器的状态是否正常，这是Docker 1.12引入的新指令。通过该指令指定一行命令，用这行命令来判断容器主进行的服务状态是否还正常，从而比较真实地反映容器实际状态。

当在一个镜像指定了`HEALTHCHECK`指令后，用其启动容器，初始状态会为`starting`，在`HEALTHCHECK`指令检查成功后变为`healthy`，如果连续一定次数失败，则会变为`unhealthy`。

`HEALTHCHECK`支持下列选项：

- `--interval=<间隔>`：两次健康检查的间隔，默认为30秒
- `--timeout=<时长>`：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认为30秒
- `--retries=<次数>`：当连续失败指定次数后，则将容器状态视为`unhealthy`，默认为3次

和`CMD`、`ENTRYPOINT`一样，`HEALTHCHECK`只可以出现一次，如果写了多个，只有最后一个生效。

在`HEALTHCHECK [选项] CMD`后面的命令，格式和`ENTRYPOINT`一样，分为`shell`格式和`exec`格式。命令的返回值决定了该次健康检查的成功与否：`0`：成功，`1`：失败，`2`：保留。

## 备注

### RUN CMD ENTRYPOINT的对比

1. `RUN`执行命令并创建新的镜像层，`RUN`经常用于安装软件包
2. `CMD`设置容器启动后默认执行的命令及其参数，但`CMD`能够被`docker run`后面跟的命令行参数替换
3. `ENTRYPOINT`配置容器启动时运行的命令，`CMD`的内容会作为参数传给`ENTRYPOINT`指令

### 保持docker的运行不退出

我们前面说过，Docker不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用`systemd`去启动后台服务，容器内没有后台服务的概念。

因此想要在docker中运行后台进程而不退出，就需要在前台运行一个进程，这个进程通常没有实际意义，仅仅是为了保持docker不退出。比如：

```
tail -f /dev/null
```









> https://yeasy.gitbooks.io/docker_practice/image/build.html