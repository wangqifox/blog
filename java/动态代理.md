---
title: 动态代理
---


# 动态代理

动态代理的实现方式:

```java

public interface Subject {
	public void doSomething(String str);
}

public class RealSubject implements Subject {
	public void doSomething(String str) {
		System.out.println("do something!---->" + str);
	}
}

/**
 * 动态代理的Handler类
 */
public class MyInvocationHandler implements InvocationHandler {
	// 被代理的对象
	private Object target = null;
	public MyInvocationHandler(Object obj) {
		this.target = obj;
	}
	
	public Object invoke(Object proxy, Method method, Object[] args) throw Throwable {
		return method.invoke(this.target, args);
	}
}

public class Client {
	public static void main(String[] args) {
        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(new RealSubject());
        Subject subject = (Subject) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]{Subject.class}, myInvocationHandler);
        subject.doSomething("test");
    }
}

```

## 原理
<!--more-->
newProxyInstance方法返回通过动态代理生成的对象

```java

public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throw IllegalArgumentException {
	Objects.requireNonNull(h);
	
	final Class<?>[] intfs = interfaces.clone();
	final SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
		checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
	}
	
	// 寻找或生成指明的代理类
	Class<?> cl = getProxyClass0(loader, intfs);
	
	// 使用指定的invocation handler调用它的构造函数
	try {
		if (sm != null) {
			checkNewProxyPermission(Reflection.getCallerClass(), cl);
		}
		// 获取代理对象的构造方法
		final Constructor<?> cons = cl.getConstructor(constructorParams);
		final InvocationHandler ih = h;
		if (!Modifier.isPublic(cl.getModifiers())) {
			AccessController.doPrivileged(new PrivilegedAction<Void>() {
				public Void run() {
					cons.setAccessible(true);
					return null;
				}
			});
		}
		// 生成代理类的实例并把InvocationHandler的实例传给它的构造方法
		return cons.newInstance(new Object[]{h});
	} catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}

```

getProxyClass0方法生成一个代理类

```java
private static Class<?> getProxyClass0(ClassLoader loader, Class<?>... interfaces) {
	if (interfaces.length > 65535) {
		throw new IllegalArgumentException("interface limit exceeded");
	}
	// 如果由给定加载器和接口定义的代理类已经存在，则简单地返回缓存的副本，否则通过ProxyClassFactory创建代理类
	return proxyClassCache.get(loader, interfaces);
}
```

其中proxyClassCache的定义如下:

```java
private static final WeakCache<ClassLoader, Class<?>[], Class<?>> proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());
```

KeyFactory将接口数组映射为一个key对象：

```java
private static final class KeyFactory implements BiFunction<ClassLoader, Class<?>[], Object> {
	@Override
	public Object apply(ClassLoader classLoader, Class<?>[] interfaces) {
		switch (interfaces.length) {
			case 1: return new Key1(interfaces[0]);
			case 2: return new Key2(interfaces[0], interfaces[1]);
			case 0: return key0;
			default: return new KeyX(interfaces);
		}
	}
}
```

ProxyClassFactory是一个工程方法，生成、定义、返回给定加载器和接口数组定义的代理类：

```java
private static final class ProxyClassFactory implements BiFunction<ClassLoader, Class<?>[], Class<?>> {
	// 代理类名称的前缀
	private static final String proxyClassNamePrefix = "$Proxy";
	// 用于产生唯一代理名称的数字
	private static final AtomicLong nextUniqueNumber = new AtomicLong();
	
	@Override
	public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
		Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
		for (Class<?> intf : interfaces) {
			// 检查接口由加载器解析后的类对象和接口相同
			Class<?> interfaceClass = null;
			try {
				interfaceClass = Class.forName(intf.getName(), false, loader);
			} catch (ClassNotFoundException e) {
			}
			if (interfaceClass != intf) {
				throw new IllegalArgumentException(intf + " is not visible from class loader");
			}
			// 检查接口由加载器解析后的类对象确实是接口
			if (!interfaceClass.isInterface()) {
				throw new IllegalArgumentException(interfaceClass.getName() + " is not an interface");
			}
			// 检查接口没有重复
			if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
				throw new IllegalArgumentException("repeated interface: " + interfaceClass.getName());
			}
		}
		
		String proxyPkg = null;
		int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
		
		// 记录非公共代理接口的包，代理类定义在相同的包中。检查所有非公共的代理接口在相同的包中。
		for (Class<?> intf : interfaces) {
			int flags = intf.getModifiers();
			if (!Modifier.isPublic(flags)) {
				accessFlags = Modifier.FINAL;
				String name = intf.getName;
				int n = name.lastIndexOf('.');
				String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
				if (proxyPkg == null) {
					proxyPkg = pkg;
				} else if (!pkg.equals(proxyPkg)) {
					throw new IllegalArgumentException("non-public interfaces from different packages");
				}
			}
		}
		
		if (proxyPkg == null) {
			proxyPkg = ReflectUtil.PROXY_PACKAGE = ".";
		}
		
		// 为生成的代理类选择一个名称
		long num = nextUniqueNumber.getAndIncrement();
		String proxyName = proxyPkg + proxyClassNamePrefix + num;
		
		// 生成指定的代理类的字节码
		byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
		try {
			// 根据代理类的字节码生成代理类的实例
			return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
		} catch(ClassFormatError e) {
			throw new IllegalArgumentException(e.toString());
		}
	}
}
```

ProxyGenerator.generateProxyClass生成代理类class字节码

```java
public static byte[] generateProxyClass(final String name, Class<?>[] interfaces, int accessFlags) {
	ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);
	// 动态生成代理类的字节码
	final byte[] classFile = gen.generateClassFile();
	
	if (saveGeneratedFiles) {
		java.security.AccessController.doPrivileged(
			new java.security.PrivilegedAction<Void>() {
				public Void run() {
					try {
						int i = name.lastIndexOf('.');
						Path path;
						if (i > 0) {
							Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar));
							Files.createDirectories(dir);
							path = dir.resole(name.substring(i+1, name.length()) + ".class");
						} else {
							path = Paths.get(name + ".class");
						}
						Files.write(path, classFile);
						return null;
					} catch (IOException e) {
						throw new InternalError("I/O exception saving generated file: " + e);
					}
				}
			}
		);
	}
	return classFile;
}

```

用以下代码可以获取到JDK为我们生成的字节码写到硬盘中：

```java
public class ProxyGeneratorUtils {
    public static void writeProxyClassToHardDisk(String path) {
        byte[] classFile = ProxyGenerator.generateProxyClass("$Proxy11", UserServiceImpl.class.getInterfaces());
        FileOutputStream out = null;
        try {
            out = new FileOutputStream(path);
            out.write(classFile);
            out.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

运行以下代码生成代理类文件:

```java
ProxyGeneratorUtils.writeProxyClassToHardDisk("$Proxy11.class");
```


生成的class文件经过反编译:

```java

import dynamic_proxy.p1.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy11 extends Proxy implements Subject {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    // 构造方法，参数就是刚才传过来的MyInvocationHandler类的实例
    public $Proxy11(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    // 这是关键方法
    public final void doSomething(String var1) throws  {
        try {
            // 实际上就是调用MyInvocationHandler的public Object invoke(Object proxy, Method method, Object[] args)方法
            super.h.invoke(this, m3, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final int hashCode() throws  {
        try {
            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m3 = Class.forName("dynamic_proxy.p1.Subject").getMethod("doSomething", Class.forName("java.lang.String"));
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}

```

