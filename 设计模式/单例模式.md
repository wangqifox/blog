# 单例模式实现方式

## 懒汉式

```java

public class Singleton {
	private volatile static Singleton uniqueInstance = null;
	
	private Singleton() {}
	
	public static Singleton getInstance() {
		// 双重检查加锁
		if (uniqueInstance == null) {
			synchronized(Singleton.class) {
				if (uniqueInstance == null) {
					uniqueInstance = new Singleton();
				}
			}
		}
		return uniqueInstance;
	}
	
}

```

## 饿汉式

```java

public class Singleton {
	/**
	 * static变量在类装载的时候进行初始化
	 * 多个实例的static变量会共享同一块内存区域
	 */
	private static Singleton uniqueInstance = new Singleton();
	
	private Singleton() {}
	
	public static Singleton getInstance() {
		return uniqueInstance;
	}
}

```

## 类级内部类方式

类级内部类：

- 简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。
- 类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。
- 类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。
- 类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载

某些情况中，JVM已经隐含地执行了同步，这些情况下不用再进行同步控制，包括：

- 由静态初始化器(在静态字段上或static{}块中的初始化器)初始化数据时
- 访问final字段时
- 在创建线程之前创建对象时
- 线程可以看见它将要处理的对象时

```java
public class Singleton {
	/**
	 * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载
	 */
	private static class SingletonHolder {
		/**
		 * 静态初始化器，由JVM来保证线程安全
		 */
		private static Singleton instance = new Singleton();
	}
	
	private Singleton() {}
	
	public static Singleton getInstance() {
		return SingletonHolder.instance;
	}
}
```

当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。

这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。

## 枚举模式

- Java的枚举类型实质上是功能齐全的类，因此可以有自己的属性和方法
- Java枚举类型的基本思想是通过公有的静态final域为每个枚举常量导出实例的类
- 从某个角度讲，枚举是单例的泛型化，本质上是单元素的枚举

```java
public enum Singleton {
	/**
	 * 定义一个枚举的元素，它就代表了Singleton的一个实例
	 */
	uniqueInstance;
}
```
